\documentclass[11pt]{article}
\usepackage[a4paper,  margin=1in]{geometry}
\usepackage{enumitem}
\usepackage{color}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{codebg}{rgb}{0.95,0.95,0.9}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	rulecolor=\color{codebg},
	backgroundcolor=\color{codebg},
  language=C++,
  aboveskip=3mm,
  belowskip=-0.5mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
	morekeywords={vector},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\setlength\parskip{6pt}
\setlength\parindent{0pt}
\linespread{1}
\renewcommand{\refname}{\vspace{-30pt}}

\title{\bf{VFX Project 1\\\large{High Dynamic Range Imaging}}\vspace{-10pt}}
\author{Daikon Sun, Shang-Wei Chen}
\date{}
\begin{document}
\maketitle
\section{Description}
In this project, we assemble high dynamic range (HDR) images from a series of photographs under various exposures, using a popular vision library, OpenCV, for image processing and I/O. The photographs are preprocessed using median threshold bitmap (MTB) algorithm for image alignment. With the aid of tone mapping algorithm, HDR images are reproduced to LDR images in a better human perceptual sense. We learned basic photographing theories and image processing skills from the project. 

\section{Implementation}
\subsection{Environment}
\begin{itemize}
	\itemsep=-2pt
	\item Camera: Sony A6000 (lens: Sony SELP1650)
	\item OS: Linux (Arch, Ubuntu 16.04)
	\item Tools/Libraries: gcc/g++ 6.3.1, OpenCV 3.2 (C++), Boost $>$ 1.5, Cmake $>$ 3.0
\end{itemize}

\subsection{Image alignment}
Before HDR processing, image alignment is involved for better performance. The algorithm we used is shown in \textbf{Algorithm 1}, which is an implementation of median threshold bitmap (MTB) algorithm \cite{ref:Ward}. The function 

\begin{lstlisting}
  void MTB::process(vector<Mat>& res, int max_level, int max_denoise)
\end{lstlisting}

takes \texttt{cv::Mat} images for input and pass the result by reference. The alignment function transforms these images to 8-bit grayscale ones, while the others may approximately use only the green channel since this channel is higher weighted when converting color. Applying multi-scale techniques, we then form a pyramid of each grayscale photo in which the photos are scaled by a factor of two in each dimension. Consequently, filtering the photos to generate bitmaps thresholded by the median in each photo; thus, the bitmaps can be viewed as black-and-white photos. We can compute the amount of differences between two bitmaps using bitwise XOR, and find the optimal way to shift photos. Finally, scale these photos to crop the blank pixels on the edges resulted from shifting. There might be noisy areas at which the pixel luminance is close to the median; hence, adding a mask to exclude these areas may help following alignment processes. These features are realized by the following functions:

\begin{lstlisting}
  void MTB::transform_bi(const Mat& m, Mat& bi, Mat& de, int max_denoise)
  pair<int, int> MTB::align(const int j, int lev, const int max_level)
\end{lstlisting}

One may refer to \texttt{src/mtb.hpp} and \texttt{src/mtb.cpp} for more details. 

\begin{algorithm}
\caption{MTB algorithm}
\begin{algorithmic}[1]
\Function{MtbProcess}{$pics, max\_level, max\_denoise$}
	\State $N\gets$ number of $pics$
	\State $bi\_pics, masks\gets$ new image array with dimension $N$ and $max\_level$
	\For{$i$ in range($N$)}
		\State $p\gets pics[i]$
		\For{$j$ in range($max\_level$)}
			\State \Call{MtbTransformBi}{$p, bi\_pics[N][j], masks[N][j], max\_denoise$}
			\State $pic\gets pic$ with half size
		\EndFor
	\EndFor
	\State $offsets\gets$ array of size $N$
	\ForAll{$i$ in range($N$)}
		\State $offsets[i]\gets$\Call{MtbAlign}{i, 0, $max\_level$}
	\EndFor
	\State Shift $pics$ with $(xshift, yshift)$ pairs in $offsets$
	\State Scale $pics$ to crop blank pixels
\EndFunction
\Statex
\Function{MtbTransformBi}{$p, bi, de, max\_denoise$}
	\State $bi, de\gets p$ converted to gray scale
	\State $m\gets$ median value of all pixel in $bi$
	\ForAll{pixel $i$ in $bi$}
		\If{$i.value<m$}
			\State $i.value\gets gray.value.min$
		\Else
			\State $i.value\gets gray.value.max$
		\EndIf
	\EndFor
	\ForAll{pixel $i$ in $de$}
		\If{$i.value<m-max\_denoise$ or $i.value>m+max\_denoise$}
			\State $i.value\gets gray.value.max$
		\Else
			\State $i.value\gets gray.value.min$
		\EndIf
	\EndFor
\EndFunction
\Statex
\Function{MtbAlign}{$i, level, max\_level$}
	\If{$level$ equals $max\_level$}
		\State \Return{$(0, 0)$}
	\EndIf
	\State $(xshift, yshift)\gets$\Call{MtbAlign}{$i, level+1, max\_level$}
	\Comment{Call this function recursively}
	\State $fixed, moved\gets bi[0][level], bi[i][level]$
	\Comment{Align $pic[i]$ to $pic[0]$}
	\State $mask\_f, mask\_m\gets masks[0][level], masks[i][level]$
	\For{$xshift, yshift$ in $[-1, 0, 1]$}
		\State $moved\_sh\gets moved$ with $(xshift, yshift)$
		\State $cnt_k\gets$ \# of diff between $fixed$ and $moved\_sh$
without $mask\_f$ and $mask\_m$ area	
	\EndFor
	\State $(xshift\_best, yshift\_best)\gets(xshift, yshift)$ with min\{$cnt_k$\}
	\State\Return$(xshift*2+xshift\_best, yshift*2+yshift\_best)$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{HDR Imaging}

\begin{algorithm}
\caption{HDR algorithm using Paul Debevec's method}
\begin{algorithmic}[1]
\State $f\gets$ user parameter for intensity
\end{algorithmic}
\end{algorithm}

One may refer to \texttt{src/hdr.hpp} and \texttt{src/hdr.cpp} for more details.

\newpage
\subsection{Tone Mapping}
The algorithm we used is an inspiration from photoreceptor physiology \cite{ref:tone-map}, which can be separated into two concepts: global and local reproduction. The part of global operators considers overall characteristics, such as contrast, brightness, color saturation, and etc., for visual perceptions. On the other hand, the part of local operators focuses on local modifications, such as haloing and ringing.

\begin{algorithm}
\caption{Tone mapping algorithm \cite{ref:tone-map}}\label{euclid}
\begin{algorithmic}[1]
\State $f\gets$ user parameter for intensity
\State $m\gets$ user parameter for contrast
\State $a\gets$ user parameter for light adaption 
\State $c\gets$ user parameter for chromatic adaption
\Function{Tonemap}{$image\_in$, $image\_out$}
\State $L\_map\gets$ luminance of each pixel in $image\_in$
\State $Cav[3]\gets$ mean value of each channels of $image\_in$
\State $Lav\gets$ mean value of $L\_map$
\State $L\_min\gets$ minimal value in $L\_map$
\State $L\_max\gets$ maximal value in $L\_map$
\ForAll{channel $n$ of $image\_in$}
\ForAll{pixel $i$ in $image\_in[n]$}
\State $L\gets$ value of the same position in $L\_map$
\State $I\_local\gets c* image\_in[n][i]+ (1-c)*L$
\State $I\_global\gets c*Cav[n]+ (1-c)* Lav$
\State $I\_adaption\gets a*I\_local+(1-a)*I\_global$
\State $image\_out[n][i]\gets image\_in[n][i]/(image\_in[n][i]+\mbox{pow}(f*I\_adaption, m))$
\EndFor
\EndFor
\State Normalize the value of pixels in $image\_out$ to an integer in the range from 0 to 255
\EndFunction
\end{algorithmic}
\end{algorithm}

One may refer to \texttt{src/tonemap.hpp} and \texttt{src/tonemap.cpp} for more details.

\section{Results}

\begin{figure}[!ht]
	\centering
	%\subcaptionbox{Ponzo illusion\vspace{5pt}}{\includegraphics[width=.3\linewidth]{Ponzo}}
	%\caption{782\cite{ref:optical-illusion}}
	\label{distort}
\end{figure}

\section{Reference}
\bibliographystyle{unsrt}
\bibliography{hw1}
\end{document}
